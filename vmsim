#!/usr/bin/env python3
import argparse
import math
import sys

class virtual_memory_sim():
    '''

    Virtual memory simulator
    Run through the memory references of the trace file
    Decide the action taken for each address 
        * memory hit
        * page fault with no eviction
        * page fault and evict clean page
        * page fault and evict dirty page
        
    After dealing with all the memory references for both simulated processes
    print out summary statistics in the following format

    '''
    def __init__(self):
        self.parser = argparse.ArgumentParser()
        self.algorithm = ''
        self.frames = 0
        self.page_size = 0
        self.memory_split = ''
        self.tracefile = ''

        self.memory_accesses = 0
        self.page_faults = 0
        self.disk_writes = 0

    def parse_args(self):
        self.parser.add_argument('-a', '--algorithm',     type=str, choices = ['opt', 'lru'])
        self.parser.add_argument('-n', '--numframes',  type=int)
        self.parser.add_argument('-p', '--pagesize',   type=int)
        self.parser.add_argument('-s', '--memorysplit',type=str)
        self.parser.add_argument('tracefile', type=str)
        contents = self.parser.parse_args()
        if (contents.algorithm != '' ): self.algorithm = contents.algorithm
        if (contents.numframes != 0): self.frames = contents.numframes
        if (contents.pagesize != 0):  self.page_size = contents.pagesize
        if (contents.memorysplit != ''): self.memory_split = contents.memorysplit
        if (contents.tracefile != ''):   self.tracefile = contents.tracefile

    def apply_split(self):
        '''
            Apply the memory split between the two processes.
                'a:b' --> where a and b are positive integers > 0 that represent the ratios of each process's memory allocation. 
                1:2 split means that the second process gets twice as many frames as the first process (i.e., the first process gets one third and the second two thirds). 
                The sum of a and b evenly divided the total number of frames.

            then initialize two objects to track each process.

            returns --> two tables with split frames.
        '''
        if (int(self.memory_split[0]) < 0 or int(self.memory_split[2]) < 0 ):
            return -1
        ratio1 = int(self.memory_split[0]) / (int(self.memory_split[0])+int(self.memory_split[2]))
        ratio2 = int(self.memory_split[2]) / (int(self.memory_split[0])+int(self.memory_split[2]))
        return [table(ratio1*self.frames), table(ratio2*self.frames)]

    
    def run_sim(self):
        tables = self.apply_split()
        for i, line in enumerate(open(self.tracefile)):
            self.memory_accesses += 1
            line = line.split(' ')
            dirty_bit = 0 if line[0]=='l' else 1
            shift  =  int(math.log(int(self.page_size),2))
            frame = str(line[1][2:(len(line[1])-(shift+1))])
            offset = line[1][(len(line[1])-shift):]
            table_idx = int(line[2][0])
            
            # miss
            # print(tables[table_idx].entries)
            if frame not in tables[table_idx].entries.keys():
                # print(frame)
                self.page_faults += 1
                frame_to_evict = None

                if tables[table_idx].isFull():

                    # find lru
                    lru = sys.maxsize
                    for addr in tables[table_idx].entries.keys():
                        if tables[table_idx].entries[addr][1] < lru:
                            lru = tables[table_idx].entries[addr][1]
                            frame_to_evict = addr
                    
                    # check dirty bit
                    if tables[table_idx].entries[frame_to_evict][0] == 1:
                        self.disk_writes += 1
                    
                    # remove entry
                    tables[table_idx].entries.pop(frame_to_evict)
                tables[table_idx].entries[frame] = (dirty_bit, i)
            # hit
            else:
                # print('found')
                # update entry with new lru_counter and dirty bit
                if tables[table_idx].entries[frame][0] == 1 or dirty_bit == 1:
                    tables[table_idx].entries[frame] = (1, i)
                else:
                    tables[table_idx].entries[frame] = (0, i)

            # # debug
            # print(str(i) + ' : ' + frame + ' : ' + str(line[2][0]))
            # print('-------------------')
            # print(tables[0].entries)
            # print(tables[1].entries)
            # print('page faults: ' + str(self.page_faults))
            # print('\n')
            # if i > 100: break

           
    
    
    # change to __str__
    def print_results(self):
        print("Algorithm: " + self.algorithm.upper())
        print("Number of frames: " + str(self.frames))
        print("Page size: " + str(self.page_size) + " KB")
        print("Total memory accesses: " + str(self.memory_accesses))
        print("Total page faults: " + str(self.page_faults))
        print("Total writes to disk: " + str(self.disk_writes))

class table():
    '''

    '''
    def __init__(self, frames):
        self.frames = frames
        self.entries = {}
    
    def isFull(self):
        if len(self.entries) == self.frames: return True
        return False


if __name__ == "__main__":
    vm_sim = virtual_memory_sim()
    vm_sim.parse_args()
    vm_sim.run_sim()
    vm_sim.print_results()