#!/usr/bin/env python3
import argparse
import math
import sys

class virtual_memory_sim():
    '''

        Virtual memory simulator
        Run through the memory references of the trace file
        Decide the action taken for each address 
            * memory hit
            * page fault with no eviction
            * page fault and evict clean page
            * page fault and evict dirty page
            
        After dealing with all the memory references for both simulated processes
        print out summary statistics in the following format

    '''
    def __init__(self):
        self.parser = argparse.ArgumentParser()
        self.algorithm = ''
        self.frames = 0
        self.page_size = 0
        self.memory_split = ''
        self.tracefile = ''
        self.memory_accesses = 0
        self.page_faults = 0
        self.disk_writes = 0

    def parse_args(self):
        self.parser.add_argument('-a', '--algorithm',     type=str, choices = ['opt', 'lru'])
        self.parser.add_argument('-n', '--numframes',  type=int)
        self.parser.add_argument('-p', '--pagesize',   type=int)
        self.parser.add_argument('-s', '--memorysplit',type=str)
        self.parser.add_argument('tracefile', type=str)
        contents = self.parser.parse_args()
        if (contents.algorithm != '' ): self.algorithm = contents.algorithm
        if (contents.numframes != 0): self.frames = contents.numframes
        if (contents.pagesize != 0):  self.page_size = contents.pagesize
        if (contents.memorysplit != ''): self.memory_split = contents.memorysplit
        if (contents.tracefile != ''):   self.tracefile = contents.tracefile

    def split_memory(self):
        '''
            Apply the memory split between the two processes.
            returns - two tables with split frames.
        '''
        if (int(self.memory_split[0]) < 0 or int(self.memory_split[2]) < 0 ):
            return -1
        ratio1 = int(self.memory_split[0]) / (int(self.memory_split[0])+int(self.memory_split[2]))
        ratio2 = int(self.memory_split[2]) / (int(self.memory_split[0])+int(self.memory_split[2]))
        return [table(ratio1*self.frames), table(ratio2*self.frames)]

    
    def run_sim(self):
        tables = self.split_memory()
        for i, line in enumerate(open(self.tracefile)):
            self.memory_accesses += 1
            line = line.split(' ')
            dirty_bit = 0 if line[0]=='l' else 1
            offset =  int(math.log(int(self.page_size),2)) + 10
            frame = int(line[1], 16) >> offset

            table_idx = int(line[2][0])

            
            prev = self.page_faults
            # miss
            # print(tables[table_idx].entries)
            if frame not in tables[table_idx].entries.keys():
                # print(frame)
                self.page_faults += 1
                frame_to_evict = None

                if tables[table_idx].isFull():

                    # find lru
                    lru = sys.maxsize
                    for addr in tables[table_idx].entries.keys():
                        if tables[table_idx].entries[addr][1] < lru:
                            lru = tables[table_idx].entries[addr][1]
                            frame_to_evict = addr
                    
                    # check dirty bit
                    if tables[table_idx].entries[frame_to_evict][0] == 1:
                        self.disk_writes += 1
                    
                    # remove entry
                    tables[table_idx].entries.pop(frame_to_evict)

                tables[table_idx].entries[frame] = [dirty_bit, i]
            # hit
            else:
                # print('found')
                # update entry with new lru_counter and dirty bit
                if tables[table_idx].entries[frame][0] == 1 or dirty_bit == 1:
                    tables[table_idx].entries[frame] = [1, i]
                else:
                    tables[table_idx].entries[frame] = [0, i]

            # # debug
            # if ( table_idx == 0):
            #     print(str(i) + ' : ' + frame + ' : ' + str(table_idx))
            #     print('-------------------')
            #     print(tables[0].entries)
            #     print(tables[1].entries)
            #     print('page faults: ' + str(self.page_faults))
            #     print('\n')
            # print(frame)
            # print('\n')
            # if i > 1: break
    


           
    
    
    # change to __str__
    def print_results(self):
        print("Algorithm: " + self.algorithm.upper())
        print("Number of frames: " + str(self.frames))
        print("Page size: " + str(self.page_size) + " KB")
        print("Total memory accesses: " + str(self.memory_accesses))
        print("Total page faults: " + str(self.page_faults))
        print("Total writes to disk: " + str(self.disk_writes))

class table():
    '''

    '''
    def __init__(self, frames):
        self.frames = frames
        self.entries = {}
    
    def isFull(self):
        if len(self.entries) == self.frames: return True
        return False


if __name__ == "__main__":
    vm_sim = virtual_memory_sim()
    vm_sim.parse_args()
    vm_sim.run_sim()
    vm_sim.print_results()